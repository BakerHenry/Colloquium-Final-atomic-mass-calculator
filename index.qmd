---
title: "Atomic Mass Calculator: Exploring Chemical Formulas"
author: "Henry Baker"
format:
  html:
    embed-resources: true
    toc: true # Table of contents
    code-fold: true # Allows hiding code blocks
    code-summary: "Show/Hide Code"
    theme: quartz
 # A clean theme for your webpage

---

# Introduction to Atomic Mass and Scientific Computing

 Welcome to what I've put together: an Atomic Mass Calculator. I wanted to show how handy scientific computing can be, especially when we use awesome tools like Python and Quarto to tackle real problems in chemistry. Basically, I've built something that can figure out the exact 'weight' – or molecular mass – of different chemical compounds just by typing in their formulas. It's way more than just a math problem; it really showcases how much easier and more precise our work gets when we let computers do the heavy lifting.

Think about it: atomic mass is one of those bedrock concepts in chemistry. Every element on the periodic table has its own unique average atomic mass. This number isn't just pulled out of thin air; it's a careful average that considers all the different versions (isotopes) of that element found in nature. When these elements link up to create molecules, all those individual atomic masses add up to give us the compound's total molecular mass. 
And trust me, that total mass is super important! We use it constantly in chemistry to figure out how much stuff we need for reactions, predict how much product we'll get, and just generally understand the quantities involved. 

Doing this by hand, especially for complex molecules, can be a real headache and prone to mistakes. That's where this calculator comes in – it takes away the grunt work, makes things faster and more accurate, and lets us focus on the bigger picture of chemical understanding. This project is all about demonstrating how powerful and essential computational tools are in today's science, making our lives a lot easier and our results much more reliable.

In this document, we will explore:
1.  The theoretical background of atomic mass.
2.  The implementation of a Python-based atomic mass calculator.
3.  Visualization of chemical data using `matplotlib`.
4.  Representation of chemical principles using LaTeX equations via `sympy`.
5.  Data presentation with `pandas` tables.

# Big picture

Looking beyond just building this calculator, I really want to make a point about how incredibly powerful and efficient scientific computing has become. If you've ever tried to do complicated calculations by hand (especially for big, complex molecules) you know it's not just boring, it's a total pain and super easy to mess up. Imagine trying to figure out the molecular weight of some giant protein with hundreds, maybe thousands, of atoms, each with their own specific quirks. Just one tiny slip of the finger or a momentary lapse in concentration, and your whole result could be off, throwing off an entire experiment. Who needs that kind of stress?

That's why bringing in automation, like what we're doing with this calculator, is a game-changer. For starters, it saves us a ton of time. What could take hours of careful number-crunching and double-checking, a computer can knock out in seconds. That means scientists and students can actually spend their brainpower on the really interesting stuff (thinking up new experiments, interpreting results, and grappling with big ideas) instead of just grinding through calculations. Plus, computers are just better at accuracy. They don't get tired or distracted; they just do the math perfectly every single time. That gives us more reliable answers, and frankly, a lot more confidence in our scientific work. 

But here's the coolest part: scientific computing lets us explore ideas super fast. Want to see what happens to a molecule's weight if you tweak its formula? Done in an instant. Want to quickly analyze a huge list of compounds? No problem. This kind of speed lets us play around with concepts, try out 'what if' scenarios, and learn so much faster than we ever could with just pen and paper. It truly pushes science forward and helps us understand the chemical world in ways that used to be impossible.

## The Problem: Calculating Molecular Mass

So, what's the main challenge we're trying to solve here? It's pretty straightforward: if someone gives us a chemical formula, like good old water (H2O) or something a bit bigger like sugar (C6H12O6), how do we get our computer to reliably figure out its total atomic mass? It's more than just adding numbers; it needs a smart approach.

To make this happen, we really need three main things to work together:
##### A List of Atomic Masses for Every Element:
 First off, we need to know how much each individual element 'weighs.' Think of it like a digital cheat sheet or a simple lookup table. Our calculator needs a clear list (which will be a Python dictionary in our code) that tells it, for example, that Hydrogen ('H') has a mass of about 1.008 atomic mass units, Oxygen ('O') is about 15.999, and so on. This list has to be accurate and include all the common elements, because the final answer depends entirely on having correct starting weights for each atom.

##### A Smart Way to Read the Chemical Formula:
 This is probably the trickiest part. A chemical formula is written for people to understand, not for computers. So, we need to teach our program how to 'read' that string of letters and numbers. For instance, if it sees Al2(SO4)3, it needs to:
##### Spot the Elements: 
Like 'Al', 'S', and 'O'.
Count Them Up: The '2' after 'Al' means two Aluminum atoms.

##### Handle Parentheses: 
The (SO4)3 part is special. It means the SO4 group appears three times. So, the program needs to know there's one Sulfur and four Oxygens inside the parentheses, and then multiply both those counts by the '3' outside. That gives us three Sulfurs and twelve Oxygens from that group. We're keeping it a little simpler for now by not dealing with parentheses inside other parentheses, but it still has to handle these common groups correctly.

##### A System to Add Up All the Masses: 
Once our program has figured out exactly how many of each type of atom are in the formula, the final step is to just total everything up. It takes the count for each element, multiplies it by that element's atomic mass from our list, and then adds all those results together. This is our 'calculation engine' – it does the exact same sum a chemist would do by hand, but super fast and without any mistakes, giving us the compound's total atomic mass.

## Key Concepts

*   **Atomic Mass Unit (amu):**     
First up, the Atomic Mass Unit, or 'amu.' This is essentially chemistry’s tiny measuring stick for the mass of atoms and molecules. Think of it like a specialized kilogram for the atomic world. Before the amu, talking about the mass of, say, a hydrogen atom in grams was incredibly cumbersome – we're talking about numbers like 0.00000000000000000000000167 grams, which is just impossible to work with day-to-day! So, scientists created the amu as a relative unit. It's defined as exactly one-twelfth the mass of a single carbon-12 atom. This means when we say hydrogen has an atomic mass of about 1.008 amu, it's relative to that carbon-12 standard, making the numbers much more manageable and meaningful. It’s the essential unit our calculator uses behind the scenes to keep everything tidy and scientifically accurate.

*   **Molecular Mass:**     
Building on the concept of atomic mass, we arrive at Molecular Mass. Simply put, this is the total mass of an entire molecule. Imagine you're putting together a LEGO structure: you add up the weight of each individual brick to get the total weight of your creation. Molecular mass works exactly the same way. When atoms bond to form a molecule, their individual atomic masses (measured in amu, of course!) are simply summed up. So, if we’re talking about water, H2O, its molecular mass is the mass of two hydrogen atoms plus the mass of one oxygen atom. For larger, more complex molecules like proteins or polymers, calculating this manually quickly becomes overwhelming, which is precisely why our computational approach is so valuable. It gives us a crucial piece of information for stoichiometry, reaction yields, and understanding chemical proportions on a macroscopic scale.

*   **Chemical Formula:**   
Finally, we have the Chemical Formula. This is the concise, standardized language chemists use to describe the composition of a compound. It's like a recipe for a molecule. For example, H2O
 tells us clearly that a water molecule is made up of two hydrogen atoms and one oxygen atom. 
C6H12O 
 is the formula for glucose, immediately revealing that it contains six carbon, twelve hydrogen, and six oxygen atoms. These formulas use element symbols from the periodic table and subscripts to indicate the number of each type of atom. Sometimes, you'll see parentheses used, like in Ca(NO3)
, to indicate a polyatomic ion (like nitrate, NO3NO3) that appears multiple times. Learning to correctly interpret and parse these formulas is the backbone of our calculator's ability to 'understand' what molecule it's working with, making it a critical bridge between human chemical notation and computational analysis.

## Implementation: Building the Calculator

So how are we actually going to build this thing and make it tick? We're going to lean heavily on Python for all the real 'heavy lifting' here, it's a wonderfully versatile language for scientific tasks, and its readability helps us tackle complex problems. The trickiest part, honestly, isn't the math itself, but rather taking a chemical formula string, like H2O or Ca(NO3)2, and precisely breaking it down. This critical initial step is technically known as 'parsing,' and it gets especially fiddly when you introduce the complexities of subscripts (like the '2' in H2O) and those sometimes-pesky parentheticals (like the (NO3) group). These structural conventions, while clear to a human chemist, require careful algorithmic design for a computer to interpret correctly.

Now, for this specific project, to keep our focus clear and our parsing logic streamlined, we'll handle formulas with parenthetical groups, but we're going to set a pragmatic boundary: we'll avoid nested parentheses. So, something like Ca(NO3)2 is perfectly fine, representing a single layer of grouping. However, a formula like Cu(NH3)4(SO4) would demand a more recursive and significantly more complex parsing algorithm than we need for this foundational demonstration. This design choice allows us to illustrate the core principles effectively without getting bogged down in advanced edge cases.

At its heart, our calculator works by maintaining a comprehensive yet easily accessible dictionary of standard atomic weights for all the common elements – think of it as its own internal periodic table 'cheat sheet.' When you input a formula, the program meticulously processes it: first, our parsing function extracts the elemental composition and their respective counts. Then, it iterates through these identified elements, cross-referencing their symbols with our atomic weights dictionary. For each element, it multiplies its atomic weight by its count in the formula, accumulating these values. This systematic process ensures that every atom contributes its precise mass to the final sum, culminating in the accurate calculation of the compound's total molecular mass. It's essentially mimicking a chemist's manual calculation, but with the speed and infallibility of a digital brain!
### Atomic Weights Data

First, let's define the atomic weights for some common elements. This will be stored in a Python dictionary. We'll use values from the IUPAC standard atomic weights.

# Charting Data

```{python}
import pandas as pd
import re # Regular expression module for parsing
from sympy import symbols, latex # For LaTeX equations
from matplotlib import pyplot as plt
import numpy as np

# Dictionary of standard atomic weights (approximate for common isotopes)
# Values are in amu (atomic mass units)
atomic_weights = {
    'H': 1.008, 'He': 4.003, 'Li': 6.941, 'Be': 9.012, 'B': 10.811,
    'C': 12.011, 'N': 14.007, 'O': 15.999, 'F': 18.998, 'Ne': 20.180,
    'Na': 22.990, 'Mg': 24.305, 'Al': 26.982, 'Si': 28.086, 'P': 30.974,
    'S': 32.065, 'Cl': 35.453, 'Ar': 39.948, 'K': 39.098, 'Ca': 40.078,
    'Sc': 44.956, 'Ti': 47.867, 'V': 50.942, 'Cr': 51.996, 'Mn': 54.938,
    'Fe': 55.845, 'Co': 58.933, 'Ni': 58.693, 'Cu': 63.546, 'Zn': 65.38,
    'Ga': 69.723, 'Ge': 72.63, 'As': 74.922, 'Se': 78.971, 'Br': 79.904,
    'Kr': 83.798, 'Rb': 85.468, 'Sr': 87.62, 'Y': 88.906, 'Zr': 91.224,
    'Nb': 92.906, 'Mo': 95.96, 'Tc': 98.0, 'Ru': 101.07, 'Rh': 102.91,
    'Pd': 106.42, 'Ag': 107.87, 'Cd': 112.41, 'In': 114.82, 'Sn': 118.71,
    'Sb': 121.76, 'I': 126.90, 'Xe': 131.29, 'Cs': 132.91, 'Ba': 137.33,
    'La': 138.91, 'Ce': 140.12, 'Pr': 140.91, 'Nd': 144.24, 'Pm': 145.0,
    'Sm': 150.36, 'Eu': 151.96, 'Gd': 157.25, 'Tb': 158.93, 'Dy': 162.50,
    'Ho': 164.93, 'Er': 167.26, 'Tm': 168.93, 'Yb': 173.05, 'Lu': 174.97,
    'Hf': 178.49, 'Ta': 180.95, 'W': 183.84, 'Re': 186.21, 'Os': 190.23,
    'Ir': 192.22, 'Pt': 195.08, 'Au': 196.97, 'Hg': 200.59, 'Tl': 204.38,
    'Pb': 207.2, 'Bi': 208.98, 'Po': 209.0, 'At': 210.0, 'Rn': 222.0,
    'Fr': 223.0, 'Ra': 226.0, 'Ac': 227.0, 'Pa': 231.04, 'Th': 232.04,
    'Np': 237.0, 'U': 238.03, 'Am': 243.0, 'Pu': 244.0, 'Cm': 247.0,
    'Bk': 247.0, 'Cf': 251.0, 'Es': 252.0, 'Fm': 257.0, 'Md': 258.0,
    'No': 259.0, 'Rf': 261.0, 'Lr': 262.0, 'Db': 262.0, 'Bh': 264.0,
    'Sg': 266.0, 'Mt': 268.0, 'Rg': 272.0, 'Hs': 277.0
}

print("Loaded atomic weights for 100+ elements.")



def parse_formula(formula):
    """
    Parses a chemical formula string into a dictionary of element counts.
    Handles basic formulas and parentheticals.

    Args:
        formula (str): The chemical formula string (e.g., "H2O", "Ca(NO3)2").

    Returns:
        dict: A dictionary where keys are element symbols and values are their counts.
              Returns an empty dict if parsing fails or element not found.
    """
    elements = {}
    # Pattern to match elements (e.g., H, He) and optional numbers (e.g., 2, 10)
    # Also handles groups in parentheses (e.g., (NO3)2)
    # Element: [A-Z][a-z]?
    # Number: [0-9]* (empty string if no number, means count 1)
    # Group: \(([A-Za-z0-9]+)\)([0-9]*)
    # This regex is an extension for groups:
    pattern = re.compile(r'([A-Z][a-z]?)([0-9]*)|(\(([A-Za-z0-9]+)\)([0-9]*))')

    i = 0
    while i < len(formula):
        match = pattern.match(formula, i)
        if not match:
            # If no match, it could be a parsing error or end of string
            # For simplicity, we'll stop and report what we've found so far
            print(f"Warning: Could not parse '{formula[i:]}' in formula '{formula}'")
            return {} # Return empty to indicate failure or partial parsing

        element_symbol = match.group(1)
        element_count_str = match.group(2)
        group_formula = match.group(4)
        group_multiplier_str = match.group(5)

        if element_symbol: # It's a single element
            count = int(element_count_str) if element_count_str else 1
            elements[element_symbol] = elements.get(element_symbol, 0) + count
            i += len(match.group(0))
        elif group_formula: # It's a parenthetical group
            multiplier = int(group_multiplier_str) if group_multiplier_str else 1
            # Recursively parse the group formula
            sub_elements = parse_formula(group_formula)
            for el, num in sub_elements.items():
                elements[el] = elements.get(el, 0) + (num * multiplier)
            i += len(match.group(0))
        else:
            # Should not happen if regex is comprehensive, but as a safeguard
            print(f"Error: Unknown parsing state at index {i} in '{formula}'")
            return {}

    return elements

# Test the parser
print("\nTesting the formula parser:")
print(f"H2O: {parse_formula('H2O')}")
print(f"C6H12O6: {parse_formula('C6H12O6')}")
print(f"Ca(NO3)2: {parse_formula('Ca(NO3)2')}")
print(f"Al2(SO4)3: {parse_formula('Al2(SO4)3')}")



def calculate_atomic_mass(formula):
    """
    Calculates the total atomic mass of a chemical formula.

    Args:
        formula (str): The chemical formula string.

    Returns:
        tuple: (float, dict) The total atomic mass and a dictionary of element masses,
               or (None, None) if an unknown element is found or formula fails to parse.
    """
    element_counts = parse_formula(formula)
    if not element_counts:
        print(f"Error: Could not parse formula '{formula}' or no elements found.")
        return None, None

    total_mass = 0.0
    element_masses = {}

    for element, count in element_counts.items():
        if element in atomic_weights:
            mass = atomic_weights[element] * count
            total_mass += mass
            element_masses[element] = mass
        else:
            print(f"Error: Unknown element '{element}' in formula '{formula}'.")
            return None, None # Indicate failure due to unknown element

    return total_mass, element_masses

# Let's test the full calculator with some examples
print("\n--- Atomic Mass Calculator Examples ---")
formulas_to_test = ["H2O", "C6H12O6", "NaCl", "Ca(NO3)2", "Al2(SO4)3", "H2SO4", "CH3COOH"]

results_df_data = []

for formula in formulas_to_test:
    mass, element_masses = calculate_atomic_mass(formula)
    if mass is not None:
        print(f"Formula: {formula}")
        print(f"  Total Atomic Mass: {mass:.3f} amu")
        row_data = {"Formula": formula, "Total Mass (amu)": f"{mass:.3f}"}
        for el, el_mass in element_masses.items():
            row_data[f"{el} Mass"] = f"{el_mass:.3f}"
        results_df_data.append(row_data)
    else:
        print(f"  Could not calculate mass for {formula} due to errors.")
        results_df_data.append({"Formula": formula, "Total Mass (amu)": "Error"})

# Creating a DataFrame to display results
results_df = pd.DataFrame(results_df_data)
# Fill NaN values with a dash for cleaner display if an element mass column doesn't apply to a formula
results_df = results_df.fillna("-")

print("\n### Calculation Summary Table")
print("Here's a summary of the calculations for various chemical formulas:")
results_df



#| label: fig-pie-chart
#| fig-cap: "Mass Contribution of Elements in Glucose (C6H12O6)"

formula_for_viz = "C6H12O6" # Glucose
mass_glucose, element_masses_glucose = calculate_atomic_mass(formula_for_viz)

if mass_glucose:
    labels = element_masses_glucose.keys()
    sizes = element_masses_glucose.values()
    colors = plt.cm.Paired(np.arange(len(labels))) # Use a colormap for variety

    fig, ax = plt.subplots(figsize=(8, 8))
    wedges, texts, autotexts = ax.pie(sizes, labels=labels, autopct='%1.1f%%',
                                      startangle=90, colors=colors,
                                      pctdistance=0.85, wedgeprops={'edgecolor': 'black'})

    # Adjust autopct texts for better visibility if needed
    for autotext in autotexts:
        autotext.set_color('white') # Set text color to white for better contrast
        autotext.set_fontsize(10)

    # Set title and ensure equal aspect ratio for a circular pie chart
    ax.set_title(f'Mass Contribution in {formula_for_viz} (Total: {mass_glucose:.2f} amu)',
                 fontsize=14, pad=20)
    ax.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle.
    plt.show()
else:
    print(f"Could not generate pie chart for {formula_for_viz}.")



    # Define symbolic variables using sympy
n_i = symbols('n_i') # Count of element i
A_i = symbols('A_i') # Atomic mass of element i
k = symbols('k') # Number of distinct elements
M = symbols('M') # Molecular mass
i_sym = symbols('i') # Index for summation

# Express the summation formula
# molecular_mass_formula = M - sum(n_i * A_i for i_sym in range(k)) # This is conceptual

# A simpler way to show the general equation with sympy's LaTeX output:
# This creates a more generic sum symbol directly.
from sympy import Sum, IndexedBase, Idx
A = IndexedBase('A')
n = IndexedBase('n')
i = Idx('i')

molecular_mass_sum_expr = Sum(n[i] * A[i], (i, 1, k))


```

While numbers and tables are incredibly precise, sometimes the best way to truly grasp scientific data is through visualization. This is where matplotlib, Python's foundational plotting library, becomes indispensable. For our atomic mass calculator, we can leverage matplotlib to create compelling visual representations that quickly convey complex information, making our analysis much more intuitive and accessible. Specifically, a pie chart is an excellent tool here because it's fantastic for showing how different parts contribute to a whole – in our case, how each element's total mass contributes to the overall molecular mass of a compound.

Consider a molecule like glucose (C6H12O). Just looking at the formula tells us there are six carbons, twelve hydrogens, and six oxygens. But how much 'mass' does each of those elements actually bring to the party? It's not immediately obvious that six carbon atoms contribute far more mass than twelve hydrogen atoms due to their differing atomic weights. A pie chart cuts through this numerical abstraction, offering an instant visual breakdown. Each 'slice' of the pie represents a specific element, and the size of that slice is directly proportional to the total mass contributed by all atoms of that element within the molecule. This allows us to quickly identify the dominant mass contributors and understand the elemental composition's mass-based stoichiometry at a glance.

The Python code block that follows is responsible for generating this visualization. It first calls our calculate_atomic_mass function for a chosen formula (e.g., glucose) to get the individual mass contributions of each element. Then, matplotlib takes these values to draw the pie chart. We're carefully setting labels, colors (using a nice colormap for clarity), and auto-percentages to ensure the chart is both informative and aesthetically pleasing. We also adjust the title and aspect ratio to make sure it's presented clearly and professionally. This dynamic generation of plots directly from our calculations within the Quarto document truly showcases the power of scientific computing to transform raw data into insightful, easy-to-understand visual stories, making complex chemical concepts much more approachable.

```{python}
#| output: asis

print("\n### Molecular Mass General Formula (LaTeX via SymPy)")
print("The general formula for molecular mass (M) can be represented as:")
print(f"$$\nM = {latex(molecular_mass_sum_expr)}\n$$")
```

Beyond just numbers and plots, scientific communication often relies heavily on clear and precise mathematical notation, especially in fields like chemistry and physics. This is where sympy, Python's library for symbolic mathematics, becomes an incredibly powerful ally. It allows us to not only work with mathematical expressions symbolically (meaning with variables and equations, not just numbers) but also to render them beautifully using LaTeX, the gold standard for scientific typesetting. You know, those crisp, professional-looking equations you see in textbooks and research papers? sympy helps us generate those directly within our Quarto document.

Why is this important for our atomic mass calculator? Because the process of calculating molecular mass isn't just a series of steps; it's governed by a fundamental mathematical principle. We can formally state this principle using sympy to generate a generalized equation. This capability allows us to clearly articulate the theoretical basis of our work, moving beyond just showing the numerical outcome to explaining the underlying mathematical relationship. It reinforces the academic rigor of our project and demonstrates how computational tools can bridge the gap between abstract mathematical theory and concrete chemical application. 

By explicitly showing the formula for molecular mass in its elegant LaTeX form, we provide immediate clarity and a universally understood representation for anyone reading our work. This isn't just about making things look pretty; it's about making our science unequivocally understandable and professionally presented. 

The code block below uses sympy to define symbolic variables for the number of atoms (nini), the atomic mass (Ai), and the total number of distinct elements (k), then constructs the summation formula that represents molecular mass. When Quarto renders this, sympy translates that symbolic expression into the high-quality LaTeX output you see, seamlessly integrating advanced mathematical typesetting into our dynamic webpage. This formal expression is a cornerstone of quantitative chemistry.

# Perchance.